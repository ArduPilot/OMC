/*
 * Copyright (c) 2020 Intel Corporation
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package eu.mavinci.flightplan.asctec;

import com.ochafik.lang.jnaerator.runtime.Structure;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import eu.mavinci.core.obfuscation.IKeepAll;
import eu.mavinci.core.obfuscation.IKeepAll;

import java.util.Arrays;
import java.util.List;

/**
 * <i>native declaration : line 2</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a
 * href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
/*
 * * unsigned short id; //Set to any ID. E.g. number of waypoint in your planning. Will be feed back in ATOS_DBG_NAV_STATUS float lat;
 * //latitude//decimal degrees//or Y[m] float lon; //longtiude//decimal degrees//or X[m] float height; //height above starting point//m
 * short camAnglePitch;//cam pitch angle//100th deg short camAngleRoll;//cam roll angle//100th deg unsigned short camAngleYaw;//cam yaw
 * angle//100th deg float speed; //max speed//m/s float desiredAcceleration; //acceleration to reach speed and 0//m/s^2 // Good values are
 * between 1.0 (very smooth) to 4.0 (sporty) unsigned int flags;//flags. NAV_FLAGS_* are ignored in all waypoints except wayppoint[0] (see
 * step a) WP_FLAG_PREPARED_FOR_UPLOAD //not covered in this documentation WP_FLAG_CAM_PITCH_ACTIVE //set if camera pitch is changed to
 * camAnglePitch for this waypoint WP_FLAG_CAM_ROLL_ACTIVE //set if camera roll is changed to camAngleRoll for this waypoint. Not
 * implemented yet. WP_FLAG_CAM_YAW_ACTIVE //set if camera yaw (=vehicle yaw for Falcon 8) is changed to camAngleYaw for this waypoint. Is
 * only used when no NAV_FLAG_HEADING_ are set in waypoint[0] WP_FLAG_START_MOTORS //auto start motors. Not implemented yet
 * WP_FLAG_STOP_MOTORS //land and stop motors. Not implemented yet WP_FLAG_YAW_ACTIVE //not implemented yet. For future systems with
 * seperate camera and vehicle yaw WP_FLAG_HEIGHT_ACTIVE //Not implemented yet. Would activate/deactivate height from this structure
 * WP_FLAG_RELATIVE_COORDS //relative coordinates in m instead of lot/lon. Not covered in this documentation WP_FLAG_STOP //Set to mark the
 * last waypoint for this command ONLY for waypoints with WPBUFFER_ ringerbuffer! WP_FLAG_NO_PHOTO_TRIGGER //Set for instance for come home
 * command => not photo is triggered when reaching waypoint NAV_FLAG_ABSOLUTE_ORIGIN //Origin is absolute. Should be set always. In future:
 * Won't be set for relative inspection trajectories NAV_FLAG_HEADING_FIXED //vehicle heading is automatically set along the path. Makes
 * sense for trajectory flying, not for single waypoints NAV_FLAG_HEADING_BY_SEPERATE_PATH //for future video trajectorys
 * NAV_FLAG_CAMERA_ANGLE_BY_PATH //for future video trajectorys NAV_FLAG_ROTATE_PATH_TO_START_HEADING // for NAV_WPLIST_AUTO_GEN_MATRIX.
 * Don't set. NAV_FLAG_SINGLE_WAYPOINTS //set if single waypoint is used NAV_FLAG_MATRIX_SPLINE //fly matrix trajectory
 * NAV_FLAG_CUBIC_SPLINE //fly spline trajectory NAV_FLAG_PANO //used internally. Don't set NAV_FLAG_RING_BUFFER //set in waypoint[0] (Step
 * a) when ringbuffer is used instead of complete waypoint list
 *
 * unsigned char event1; //Event 1. Currently implemented: NAV_EVENT_TRIGGER=Trigger Camera. Currently for single waypoints ONLY! Trajectory
 * flight automatically trigger the camera unsigned char event2; //Event 2. Currently implemented: NAV_EVENT_TRIGGER=Trigger Camera.
 * Currently for single waypoints ONLY! Trajectory flight automatically trigger the camera unsigned short waitTimeEvent1;//time in ms //
 * Waittime in ms at single waypoints before event 1 is triggered. unsigned short waitTimeEvent2;//time in ms // Waittime in ms at single
 * waypoints before event 2 is triggered. Set event 2 for NAV_EVENT_NONE to create a waittime for the camera to actually trigger before the
 * next waypoint is engaged. unsigned short parameterEvent1; //not used yet unsigned short parameterEvent2; //not used yet
 */
public class ATOS_WAYPOINT extends Structure<ATOS_WAYPOINT, ATOS_WAYPOINT.ByValue, ATOS_WAYPOINT.ByReference>
        implements IKeepAll {
    public short id;
    /** VT_SINGLE//latitude//decimal degrees * 10000000 */
    public int lat;
    /** VT_SINGLE//longtiude//decimal degrees * 10000000 */
    public int lon;
    /** VT_SINGLE//height above starting point//m */
    public float height;
    /** VT_INT16//cam pitch angle//*100th deg */
    public short camAnglePitch;
    /** VT_INT16//cam roll angle//100th deg */
    public short camAngleRoll;
    /** VT_UINT16//cam yaw angle//100th deg */
    /** UNSIGNED SHORT IN C++ --> PASS ONLY POSITIVE VALUES (ORIENTATION.GETYAW RETURNS PROPER ANGLE) */
    public short camAngleYaw;
    /** VT_SINGLE//max speed//m/s */
    public float speed;
    /** VT_SINGLE//acceleration to reach speed and 0//m/s */
    public float desiredAcceleration;
    /** VT_UINT32//flags// */
    public int flags;
    /** VT_UINT8//event. 0x01=trigger// */
    public byte event1;
    /** VT_UINT8//// */
    public byte event2;
    /** VT_UINT16//time in ms// */
    public short waitTimeEvent1;
    /** VT_UINT16//time in ms// */
    public short waitTimeEvent2;
    /** VT_UINT16//// */
    public short parameterEvent1;
    /** VT_UINT16//// */
    public short parameterEvent2;

    public ATOS_WAYPOINT() {
        super();
    }

    public static int SIZEOF = 42;

    @Override
    protected List<String> getFieldOrder() {
        return Arrays.asList(
            "id",
            "lat",
            "lon",
            "height",
            "camAnglePitch",
            "camAngleRoll",
            "camAngleYaw",
            "speed",
            "desiredAcceleration",
            "flags",
            "event1",
            "event2",
            "waitTimeEvent1",
            "waitTimeEvent2",
            "parameterEvent1",
            "parameterEvent2");
    }

    public ATOS_WAYPOINT(Pointer peer) {
        super(peer);
    }

    @Override
    protected ByReference newByReference() {
        return new ByReference();
    }

    @Override
    protected ByValue newByValue() {
        return new ByValue();
    }

    @Override
    protected ATOS_WAYPOINT newInstance() {
        return new ATOS_WAYPOINT();
    }

    public static ATOS_WAYPOINT[] newArray(int arrayLength) {
        return Structure.newArray(ATOS_WAYPOINT.class, arrayLength);
    }

    public static class ByReference extends ATOS_WAYPOINT implements Structure.ByReference {};

    public static class ByValue extends ATOS_WAYPOINT implements Structure.ByValue {};

    public static Pointer pointerFromList(List<ATOS_WAYPOINT> wps) {
        return pointerFromList(wps, 0, wps.size());
    }

    public static Pointer pointerFromList(List<ATOS_WAYPOINT> wps, int start, int end) {
        int length = end - start;
        long memory = Native.malloc(SIZEOF * length);
        Pointer p = new Pointer(memory);
        int i = 0;
        for (int j = start; j < end; j++) {
            ATOS_WAYPOINT wp = wps.get(j);

            p.setShort(i, wp.id);
            i += 2;
            p.setInt(i, wp.lat);
            i += 4;
            p.setInt(i, wp.lon);
            i += 4;
            p.setFloat(i, wp.height);
            i += 4;
            p.setShort(i, wp.camAnglePitch);
            i += 2;
            p.setShort(i, wp.camAngleRoll);
            i += 2;
            p.setShort(i, wp.camAngleYaw);
            i += 2;
            p.setFloat(i, wp.speed);
            i += 4;
            p.setFloat(i, wp.desiredAcceleration);
            i += 4;
            p.setInt(i, wp.flags);
            i += 4;
            p.setByte(i, wp.event1);
            i += 1;
            p.setByte(i, wp.event2);
            i += 1;
            p.setShort(i, wp.waitTimeEvent1);
            i += 2;
            p.setShort(i, wp.waitTimeEvent2);
            i += 2;
            p.setShort(i, wp.parameterEvent1);
            i += 2;
            p.setShort(i, wp.parameterEvent2);
            i += 2;
        }

        return p;
    }
}
