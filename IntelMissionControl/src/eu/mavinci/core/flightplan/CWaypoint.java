/**
 * Copyright (c) 2020 Intel Corporation
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package eu.mavinci.core.flightplan;

import eu.mavinci.core.plane.ICAirplane;
import eu.mavinci.flightplan.LandingPoint;

public abstract class CWaypoint extends AWaypoint implements IFlightplanIgnoreable, IFlightplanNodeBody {

    protected AltAssertModes assertAltitude;
    protected String body = "";
    private boolean reentryPoint = false;

    /*
     * protected double camYaw=0; protected double camRoll=0; protected double camPitch=0;
     */
    protected Orientation orientation = new Orientation();

    protected boolean ignore = false;
    protected SpeedMode speedMode = SpeedMode.normal;
    protected boolean assertYawOn = false;
    protected double assertYaw = 0;
    protected double speedMpSec = -1; // negative means use the values from flight plan photo settings

    protected int radius = 0; // in cm

    protected boolean triggerImageHereCopterMode;
    protected double stopHereTimeCopter; // in milliseconds
    protected boolean isBeginFlightline;

    protected double targetDistance = -1; // in meters. negative== undefined

    public boolean isBeginFlightline() {
        return isBeginFlightline;
    }

    public void setBeginFlightline(boolean isBeginFlightline) {
        if (this.isBeginFlightline == isBeginFlightline) {
            return;
        }

        this.isBeginFlightline = isBeginFlightline;
        informChangeListener();
    }

    /**
     * time to stop in milliseconds after reaching the point
     *
     * @return
     */
    public double getStopHereTimeCopter() {
        return stopHereTimeCopter;
    }

    public boolean isTriggerImageHereCopterMode() {
        return triggerImageHereCopterMode;
    }

    public void setTriggerImageHereCopterMode(boolean triggerImageHereCopterMode) {
        if (this.triggerImageHereCopterMode == triggerImageHereCopterMode) {
            return;
        }

        this.triggerImageHereCopterMode = triggerImageHereCopterMode;
        informChangeListener();
    }

    /**
     * time to stop in milliseconds after reaching the point
     *
     * @return
     */
    public void setStopHereTimeCopter(double stopHereTimeCopter) {
        if (this.stopHereTimeCopter == stopHereTimeCopter) {
            return;
        }

        this.stopHereTimeCopter = stopHereTimeCopter;
        informChangeListener();
    }

    public static final int RADIUS_MAX_WITHIN_CM = 100000; // cm

    public static final float RADIUS_MAX_WITHIN_M = (float)RADIUS_MAX_WITHIN_CM / 100f;

    public static final AltAssertModes DEFAULT_ASSERT_ALT = AltAssertModes.unasserted;
    public static final String DEFAULT_BODY = "";

    public static final String SpecialPurposeBodyPrefix = "mvinternal:";

    public static final String bodyAssureAltWP = "Autogenerated Assure Altitude at Startingpoint";

    public double getSpeedMpSec() {
        return speedMpSec;
    }

    public void setSpeedMpSec(double speedMpSec) {
        if (this.speedMpSec == speedMpSec) {
            return;
        }

        this.speedMpSec = speedMpSec;
        informChangeListener();
    }

    /**
     * sirius specific for landing more slowly
     *
     * @return
     */
    public SpeedMode getSpeedMode() {
        return speedMode;
    }

    public void setSpeedMode(SpeedMode speedMode) {
        if (speedMode == null) {
            speedMode = SpeedMode.normal;
        }

        if (this.speedMode == speedMode) {
            return;
        }

        this.speedMode = speedMode;
        informChangeListener();
    }

    public boolean getAssertYawOn() {
        return assertYawOn;
    }

    public void setAssertYawOn(boolean assertYawOn) {
        if (this.assertYawOn == assertYawOn) {
            return;
        }

        this.assertYawOn = assertYawOn;
        informChangeListener();
    }

    public double getAssertYaw() {
        return assertYaw;
    }

    public void setAssertYaw(double assertYaw) {
        while (assertYaw >= 360) {
            assertYaw -= 360;
        }

        while (assertYaw < 0) {
            assertYaw += 360;
        }

        this.assertYaw = assertYaw;
        informChangeListener();
    }

    public static double detAssertAltCircleRadius(ICAirplane plane) {
        return LandingPoint.detLandingCircleRadius(plane);
    }

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        if (body != null && !this.body.equals(body)) {
            this.body = body;
            informChangeListener();
        }
    }

    public boolean isIgnore() {
        return ignore;
    }

    public void setIgnore(boolean ignore) {
        if (this.ignore == ignore) {
            return;
        }

        this.ignore = ignore;
        informChangeListener();
    }

    public void setTargetDistance(double targetDistance) {
        if (this.targetDistance == targetDistance) {
            return;
        }

        this.targetDistance = targetDistance;
        informChangeListener();
    }

    public double getTargetDistance() {
        return targetDistance;
    }

    public boolean isCirceling() {
        return radius > 0;
    }

    public float getRadiusWithinM() {
        return (float)(radius) / 100.f;
    }

    public int getRadiusWithinCM() {
        return radius;
    }

    public void setRadiusWithinM(double radius) {
        setRadiusWithinCM((int)Math.round(radius * 100));
    }

    public void setRadiusWithinM(float radius) {
        setRadiusWithinCM(Math.round(radius * 100));
    }

    public void setRadiusWithinCM(int radius) {
        if (radius > RADIUS_MAX_WITHIN_CM) {
            radius = RADIUS_MAX_WITHIN_CM;
        }
        // normalize -0.0==+0.0 for primitives but NOT for Double or Float objects...
        if (radius <= 0) {
            radius = 0;
        }

        if (this.radius != radius) {
            this.radius = radius;
            informChangeListener();
        }
    }

    public AltAssertModes getAssertAltitudeMode() {
        return assertAltitude;
    }

    public void setAssertAltitude(AltAssertModes assertAltitude) {
        if (this.assertAltitude != assertAltitude) {
            this.assertAltitude = assertAltitude;
            informChangeListener();
        }
    }

    protected CWaypoint(
            double lon,
            double lat,
            double altWithinM,
            AltAssertModes assertAltitude,
            float radiusInM,
            String body,
            int id,
            IFlightplanContainer parent) {
        super(lon, lat, altWithinM, id, parent);
        setAssertAltitude(assertAltitude);
        setBody(body);
        setRadiusWithinM(radiusInM);
    }

    protected CWaypoint(
            double lon,
            double lat,
            int altWithinCM,
            AltAssertModes assertAltitude,
            int radiusInCM,
            String body,
            int id,
            IFlightplanContainer parent) {
        super(lon, lat, altWithinCM, id, parent);
        setAssertAltitude(assertAltitude);
        setBody(body);
        setRadiusWithinCM(radiusInCM);
    }

    protected CWaypoint(
            double lon,
            double lat,
            double altWithinM,
            AltAssertModes assertAltitude,
            float radiusInM,
            String body,
            IFlightplanContainer parent) {
        super(lon, lat, altWithinM, parent);
        setAssertAltitude(assertAltitude);
        setRadiusWithinM(radiusInM);
        setBody(body);
    }

    protected CWaypoint(
            double lon,
            double lat,
            int altWithinCM,
            AltAssertModes assertAltitude,
            int radiusInCM,
            String body,
            IFlightplanContainer parent) {
        super(lon, lat, altWithinCM, parent);
        setAssertAltitude(assertAltitude);
        setRadiusWithinCM(radiusInCM);
        setBody(body);
    }

    protected CWaypoint(
            double lon,
            double lat,
            int altWithinCM,
            AltAssertModes assertAltitude,
            int radiusInCM,
            String body,
            int id) {
        super(lon, lat, altWithinCM, id);
        setRadiusWithinCM(radiusInCM);
        setAssertAltitude(assertAltitude);
        setBody(body);
    }

    protected CWaypoint(double lon, double lat, IFlightplanContainer parent) {
        super(lon, lat, parent);
        setAltInMAboveFPRefPoint(DEFAULT_ALT_WITHIN_M);
        setAssertAltitude(DEFAULT_ASSERT_ALT);
        setBody(DEFAULT_BODY);
    }

    public String toString() {
        return "CWaypoint"; // TODO more useful name
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (o == null) {
            return false;
        }

        if (o instanceof CWaypoint) {
            CWaypoint wp = (CWaypoint)o;
            boolean eq =
                super.equals(wp)
                    && radius == wp.radius
                    && assertAltitude == wp.assertAltitude
                    && body.equals(wp.body)
                    && ignore == wp.ignore
                    && assertYawOn == wp.assertYawOn
                    && assertYaw == wp.assertYaw
                    && speedMode == wp.speedMode
                    && orientation.equals(wp.getOrientation())
                    && speedMpSec == wp.speedMpSec
                    && triggerImageHereCopterMode == wp.triggerImageHereCopterMode
                    && stopHereTimeCopter == wp.stopHereTimeCopter
                    && isBeginFlightline == wp.isBeginFlightline
                    && targetDistance == wp.targetDistance;
            return eq;
        }

        return false;
    }

    public Orientation getOrientation() {
        return orientation;
    }

    public boolean setOrientation(Orientation orientation) {
        if (this.orientation.equals(orientation)) {
            return false;
        }

        this.orientation = orientation.clone();
        informChangeListener();
        return true;
    }

    public void setCamRoll(double camRoll) {
        if (orientation.setRoll(camRoll)) {
            return;
        }

        informChangeListener();
    }

    /*
     * public double getCamPitch(){ return camPitch; }
     */
    public void setCamPitch(double camPitch) {
        if (!orientation.setPitch(camPitch)) {
            return;
        }

        informChangeListener();
    }

    /*
     * public double getCamYaw(){ return camYaw; }
     */
    public void setCamYaw(double camYaw) {
        if (!orientation.setYaw(camYaw)) {
            return;
        }

        informChangeListener();
    }

    public boolean isReentryPoint() {
        return reentryPoint;
    }

    public void setReentryPoint(boolean reentryPoint) {
        this.reentryPoint = reentryPoint;
    }
}
