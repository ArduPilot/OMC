/**
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
// This file was generated by a tool. Do not edit.
//
package org.asyncfx.beans.property;

import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.Executor;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.Observable${boxedType}Value;
import org.asyncfx.AsyncFX;
import org.asyncfx.beans.AccessController;
import org.asyncfx.beans.AccessControllerImpl;
import org.asyncfx.beans.AsyncInvalidationListenerWrapper;
import org.asyncfx.beans.AsyncSubInvalidationListenerWrapper;
import org.asyncfx.beans.DeferredListener;
import org.asyncfx.beans.SubInvalidationListener;
import org.asyncfx.beans.binding.AsyncExpressionHelper;
import org.asyncfx.beans.binding.LifecycleValueConverter;
import org.asyncfx.beans.binding.ValueConverter;
import org.asyncfx.beans.value.AsyncChangeListenerWrapper;
import org.asyncfx.beans.value.AsyncSubChangeListenerWrapper;
import org.asyncfx.beans.value.SubChangeListener;
import org.asyncfx.concurrent.Dispatcher;

#set($isNumberType = $boxedType == "Integer" || $boxedType == "Long" || $boxedType == "Float" || $boxedType == "Double")

abstract class Async${boxedType}PropertyBaseImpl$!{genericType} extends Async${boxedType}Property$!{genericType} {

    final AccessControllerImpl accessController;
    PropertyMetadata<$numberType> metadata;
    $primType value;
    boolean valid = true;
    AsyncExpressionHelper<$numberType> helper;

#if($boxedType == "Object")
    ObservableValue observable;
#else
    Observable${boxedType}Value observable;
#end

    private final long uniqueId = PropertyHelper.getNextUniqueId();
    private String name;
    private volatile boolean metadataSealed;

    Async${boxedType}PropertyBaseImpl(PropertyMetadata<$numberType> metadata) {
        this.metadata = metadata;
        this.accessController = new AccessControllerImpl();

    #if($isNumberType)
        Number initialValue = metadata.getInitialValue();
        this.value = initialValue != null ? initialValue.${primType}Value() : 0;
    #elseif($boxedType == "Boolean")
        Boolean initialValue = metadata.getInitialValue();
        this.value = initialValue != null ? initialValue.booleanValue() : false;
    #else
        this.value = metadata.getInitialValue();
    #end

        ConsistencyGroup consistencyGroup = metadata.getConsistencyGroup();
        if (consistencyGroup != null) {
            consistencyGroup.add(this);
        }
    }

    Async${boxedType}PropertyBaseImpl(PropertyObject bean, PropertyMetadata<$numberType> metadata) {
        this.metadata = metadata;
        this.accessController = bean != null ? bean.getSharedAccessController() : new AccessControllerImpl();

    #if($isNumberType)
        Number initialValue = metadata.getInitialValue();
        this.value = initialValue != null ? initialValue.${primType}Value() : 0;
    #elseif($boxedType == "Boolean")
        Boolean initialValue = metadata.getInitialValue();
        this.value = initialValue != null ? initialValue.booleanValue() : false;
    #else
        this.value = metadata.getInitialValue();
    #end

        ConsistencyGroup consistencyGroup = metadata.getConsistencyGroup();
        if (consistencyGroup != null) {
            consistencyGroup.add(this);
        }
    }

    @Override
    public long getUniqueId() {
        return uniqueId;
    }

    @Override
    public String getName() {
        long stamp = 0;
        try {
            stamp = AsyncFX.isDebuggerAttached() ? 0 : accessController.readLock(false);
            if (name == null) {
                this.name = PropertyHelper.getPropertyName(getBean(), this, metadata);
            }

            return name;
        } finally {
            accessController.unlockRead(stamp);
        }
    }

    @Override
    public AccessController getAccessController() {
        return accessController;
    }

    @Override
    public PropertyMetadata<$numberType> getMetadata() {
        boolean sealed = metadataSealed;
        if (!sealed) {
            long stamp = 0;
            try {
                stamp = accessController.readLock(false);
                sealed = metadataSealed;
                if (!sealed) {
                    metadataSealed = true;
                }
            } finally {
                accessController.unlockRead(stamp);
            }
        }

        return metadata;
    }

    @Override
    public void overrideMetadata(PropertyMetadata<$numberType> metadata) {
        long stamp = 0;
        try {
            stamp = accessController.writeLock(false);
            if (metadataSealed) {
                throw new IllegalStateException("Metadata cannot be overridden because it is sealed after first use.");
            }

            this.metadata = this.metadata.merge(metadata);

        #if ($isNumberType)
            this.value = this.metadata.getInitialValue().${primType}Value();
        #else
            this.value = this.metadata.getInitialValue();
        #end

            this.name = null;
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(InvalidationListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.addListener(helper, this, getCore(), listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(InvalidationListener listener, Executor executor) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper =
                AsyncExpressionHelper.addListener(
                    helper, this, getCore(), AsyncInvalidationListenerWrapper.wrap(listener, executor));
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void removeListener(InvalidationListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.removeListener(helper, listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(ChangeListener<? super $numberType> listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.addListener(helper, this, getCore(), listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(ChangeListener<? super $numberType> listener, Executor executor) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper =
                AsyncExpressionHelper.addListener(
                    helper, this, getCore(), AsyncChangeListenerWrapper.wrap(listener, executor));
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void removeListener(ChangeListener<? super $numberType> listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.removeListener(helper, listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

#if($boxedType == "Object")
    @Override
    public void addListener(SubInvalidationListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.addListener(helper, this, getCore(), listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(SubInvalidationListener listener, Executor executor) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper =
                AsyncExpressionHelper.addListener(
                    helper, this, getCore(), AsyncSubInvalidationListenerWrapper.wrap(listener, executor));
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void removeListener(SubInvalidationListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.removeListener(helper, listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(SubChangeListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.addListener(helper, this, getCore(), listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void addListener(SubChangeListener listener, Executor executor) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper =
                AsyncExpressionHelper.addListener(
                    helper, this, getCore(), AsyncSubChangeListenerWrapper.wrap(listener, executor));
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    @Override
    public void removeListener(SubChangeListener listener) {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            helper = AsyncExpressionHelper.removeListener(helper, listener);
        } finally {
            accessController.unlockWrite(stamp);
        }
    }
#end

    @Override
    public $primType getUncritical() {
        return get(false);
    }

    @Override
    public $primType get() {
        return get(true);
    }

    @Override
    public final void reset() {
    #if($isNumberType)
        Number initialValue = metadata.getInitialValue();
        set(initialValue != null ? initialValue.${primType}Value() : 0);
    #else
        set(metadata.getInitialValue());
    #end
    }

    @Override
    public boolean isBound() {
        long stamp = 0;

        try {
            if ((stamp = accessController.tryOptimisticRead(false)) != 0) {
                boolean bound = observable != null;
                if (accessController.validate(false, stamp)) {
                    return bound;
                }
            }

            stamp = accessController.readLock(false);
            return observable != null;
        } finally {
            accessController.unlockRead(stamp);
        }
    }

    @Override
    public boolean isBoundBidirectionally() {
        long stamp = 0;

        try {
            stamp = accessController.readLock(false);
            return AsyncExpressionHelper.containsBidirectionalBindingEndpoints(helper);
        } finally {
            accessController.unlockRead(stamp);
        }
    }

    @Override
    public void bind(final ObservableValue<? extends $numberType> source) {
        bindCore(source, null);
    }

    @Override
    public <U> void bind(final ObservableValue<? extends U> source, ValueConverter<U, $numberType> converter) {
        bindCore(source, converter);
    }

    @Override
    public void unbind() {
        long stamp = 0;

        try {
            stamp = accessController.writeLock(false);
            unbindCore();
        } finally {
            accessController.unlockWrite(stamp);
        }
    }

    protected void invalidated() {}

    @Override
    public void set($primType newValue) {
        long stamp = 0;
        boolean invalidate, fireEvent = false, eventLocked = false;
        AsyncExpressionHelper helper;

        try {
            stamp = accessController.writeLock(true);
            Dispatcher dispatcher = PropertyHelper.verifyAccess(this, metadata);
            PropertyHelper.verifyConsistency(metadata);

            if (observable != null) {
                throw new RuntimeException("A bound value cannot be set.");
            }

            if (value == newValue) {
                return;
            }

            value = newValue;
            invalidate = valid;
            helper = this.helper;

            if (invalidate) {
                valid = false;

                if (AsyncExpressionHelper.validatesValue(helper)) {
                    newValue = getCore();
                }

                if (dispatcher == null || !dispatcher.isSequential()) {
                    accessController.lockEvent();
                    eventLocked = true;
                }

                if (!(fireEvent = !accessController.isLocked())) {
                    $primType newValueCopy = newValue;
                    boolean eventLockedCopy = eventLocked;

                    accessController.defer(
                        () -> {
                            invalidated();
                            AsyncExpressionHelper.fireValueChangedEvent(helper, newValueCopy, false);

                            if (eventLockedCopy) {
                                accessController.unlockEvent();
                            }
                        });
                }
            }
        } finally {
            accessController.unlockWrite(stamp);
        }

        if (fireEvent) {
            invalidated();
            AsyncExpressionHelper.fireValueChangedEvent(helper, newValue, false);

            if (eventLocked) {
                accessController.unlockEvent();
            }
        }
    }

    $primType get(boolean critical) {
        long stamp = 0;
        boolean read = true;

        try {
            if ((stamp = accessController.tryOptimisticRead(true)) != 0) {
                boolean valid = this.valid;
                $primType value = this.value;
                PropertyMetadata<$numberType> metadata = this.metadata;
                if (accessController.validate(true, stamp)) {
                    if (critical) {
                        PropertyHelper.verifyConsistency(metadata);
                    }

                    if (valid) {
                        return value;
                    }

                    read = false;
                }
            }

            if (read) {
                stamp = accessController.readLock(true);
                if (valid) {
                    if (critical) {
                        PropertyHelper.verifyConsistency(metadata);
                    }

                    return value;
                }
            }

            long newStamp = accessController.tryConvertToWriteLock(true, stamp);
            if (newStamp == 0) {
                accessController.unlockRead(stamp);
                stamp = accessController.writeLock(true);
            } else {
                stamp = newStamp;
            }

            if (critical) {
                PropertyHelper.verifyConsistency(metadata);
            }

            return getCore();
        } finally {
            accessController.unlock(stamp);
        }
    }

    abstract $primType getCore();

    abstract <U> void bindCore(
            final ObservableValue<? extends U> source, ValueConverter<U, $numberType> converter);

    abstract void unbindCore();

    void markInvalid() {
        long stamp = 0;
        boolean invalidate;
        AsyncExpressionHelper helper;

#if($isNumberType)
        $primType currentValue = 0;
#elseif($boxedType == "Boolean")
        $primType currentValue = false;
#else
        $primType currentValue = null;
#end

        try {
            if ((stamp = accessController.tryOptimisticRead(true)) != 0) {
                boolean valid = this.valid;
                if (accessController.validate(true, stamp) && !valid) {
                    return;
                }
            }

            stamp = accessController.writeLock(true);
            invalidate = valid;
            helper = this.helper;

            if (invalidate) {
                valid = false;

                if (AsyncExpressionHelper.validatesValue(helper)) {
                    currentValue = getCore();
                }
            }
        } finally {
            accessController.unlockWrite(stamp);
        }

        if (invalidate) {
            invalidated();
            AsyncExpressionHelper.fireValueChangedEvent(helper, currentValue, false);
        }
    }

    protected void verifyAccess() {
        long stamp = 0;

        try {
            if ((stamp = accessController.tryOptimisticRead(false)) != 0) {
                PropertyMetadata metadata = this.metadata;
                if (accessController.validate(true, stamp)) {
                    PropertyHelper.verifyAccess(this, metadata);
                } else {
                    accessController.readLock(false);
                    PropertyHelper.verifyAccess(this, this.metadata);
                }
            }
        } finally {
            accessController.unlock(stamp);
        }
    }

    @Override
    public final String toString() {
        final Object bean = getBean();
        final String name = getName();
        final StringBuilder result = new StringBuilder("Async${boxedType}Property [");
        long stamp = 0;

        try {
            if (!AsyncFX.isDebuggerAttached()) {
                stamp = accessController.writeLock(false);
            }

            if (bean != null) {
                result.append("bean: ").append(bean).append(", ");
            }

            if ((name != null) && (!name.equals(""))) {
                result.append("name: ").append(name).append(", ");
            }

            if (observable != null) {
                result.append("bound, ");

                if (valid) {
                    result.append("value: ").append(AsyncFX.isDebuggerAttached() ? value : getCore());
                } else {
                    result.append("invalid");
                }
            } else {
                if (valid) {
                    result.append("value: ").append(AsyncFX.isDebuggerAttached() ? value : getCore());
                } else {
                    result.append("invalid");
                }
            }

            result.append("]");
            return result.toString();
        } finally {
            if (!AsyncFX.isDebuggerAttached()) {
                accessController.unlockWrite(stamp);
            }
        }
    }

}
